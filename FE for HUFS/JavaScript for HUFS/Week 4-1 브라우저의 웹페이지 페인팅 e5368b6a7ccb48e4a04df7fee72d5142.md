# Week 4-1. 브라우저의 웹페이지 페인팅

생성일: June 9, 2024 2:46 AM

이전 시간까지는 자바스크립트의 다양한 문법에 대해 배워봤습니다. 문법을 잘 알고 있으면 코딩할 때 내가 필요로 하는 기능들을 취사 선택해 사용할 수 있게 됩니다. 

그러나 우리가 코딩하는 프로그램은 임베디드 프로그램이나 고립된 환경의 프로그램이 아니라 실시간으로 살아움직이는 ‘웹’ 위에서 동작하는 프로그램입니다. 그렇다면 단순히 문법만 많이 안다고 해서 웹앱을 능숙하게 다루기는 어렵겠죠?

그렇기 때문에 웹 상에서 일어나는 일들을 잘 알고 있다면 내가 핸들링하고 싶은 기능이 무엇인지, 어디에 위치한 것인지 알 수 있게 됩니다.

이번 세션에서는 **웹페이지를 브라우저가 어떻게 그리는지, 내부는 어떻게 구성돼있는지**에 대해 배워봅시다.

## 웹에서의 JS

자바스크립트는 기존 웹 브라우저 환경에서 동작하는 역할과 더불어 구글의 V8 js 엔진으로 빌드된 [Node.js](https://ninjaggobugi.tistory.com/7)의 등장으로 서버 사이드에서도 애플리케이션 개발이 가능해져 클라이언트/서버 사이드 모두 커버할 수 있는 만능 언어가 되었습니다.

하지만 여전히 자바스크립트는 웹 브라우저 환경에서 가장 많이 사용되는 언어이며, 우리는 프론트엔드 트랙을 선택하여 웹 개발을 배우기 위해 여기 앉아있으므로, 필히 자바스크립트가 웹 상에서 어떻게 동작하는지 알고 있어야 합니다.

대부분의 프로그래밍 언어는 운영체제나 가상 머신(Virtual Machine) 위에서 실행되지만, 웹 어플리케이션의 클라이언트 사이드 언어인 자바스크립트는 브라우저 위에서 HTML, CSS와 함께 실행됩니다.

웹 브라우저 화면을 보면서 이해해볼까요? 

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled.png)

현재 제 크롬 검색 화면입니다. 어떤 요소들이 보이시나요?

구글의 로고와 여러 아이콘을 통틀어 이미지가 있을 것이고, 글자들의 폰트, 버튼을 누르면 상호작용이 일어나도록 자바스크립트 코드가 뒤에 숨어있을 것입니다. 

거시적으로 본다면 이 페이지는 하나의 HTML 파일과 CSS 요소로 이루어져 있습니다.

이런 요소들을 **리소스**라고 부르는데, 이 리소스들은 어떻게 우리 화면으로 가져올 수 있었을까요? 

바로 브라우저의 주소창에 우리가 통상적으로 URL이라고 부르는 주소를 입력하고 엔터 키를 눌러 리소스를 서버로부터 받아왔기 때문입니다.

## 리소스

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%201.png)

주소창에 주소를 기입하여 서버에게 요청을 보내면(Request), 서버는 해당 URI를 해석하여 필요한 리소스를 다시 브라우저에게 전달해줍니다(Response). 서버가 응답한 리소스를 가지고 브라우저는 이를 파싱(해석)하여 시각적으로 출력하게 되는 것입니다.

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%202.png)

평소에 익숙하게 부르던 URL은 URI의 부분집합이라 보시면 됩니다. 간단히 말해서 URI는 ‘클라이언트에서 서버로 요청하는 요구사항을 쿼리로 정리한 것’으로 이해하고 넘어가면 됩니다. 더 자세히 알고 싶은 분은 아래 링크를 참고하셔도 좋습니다.

[**[WEB] 🌐  URL / URI / URN 차이점**](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4)

## 리소스를 어떻게 렌더링할까?

![indent 마저 없는 순수한 html 문서의 모습입니다.](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%203.png)

indent 마저 없는 순수한 html 문서의 모습입니다.

브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트입니다. 순수한 텍스트인 HTML 문서를 브라우저가 바로 소화하면 좋겠지만 브라우저는 순수한 html 문서를 이해하지 못합니다. 

따라서 브라우저에 시각적인 픽셀로 렌더링하려면 **HTML 문서를 브라우저가 이해할 수 있는 객체로 변환**하여 메모리에 저장해줘야 합니다. 

이 때 브라우저가 이해할 수 있는 객체를 **DOM(Document Object Model)**이라 일컫는데요, 브라우저의 ‘렌더링 엔진’에 의해 HTML 문서가 한 줄씩 순차적으로 파싱되어 **위계 구조를 가지는 노드들의 집합인 DOM**을 만드는 것입니다.

### 브라우저의 내부구조

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%204.png)

브라우저의 렌더링 엔진은 위 그림처럼 꽤 아래에 위치해 있습니다. 우리가 보고 있는 브라우저는 사실 겉표면, 빙산의 일각에 불과하죠. 버튼을 누르면 아래 수많은 엔진들이 동작하고 그 결과물을 보여주는 것 뿐입니다.

- [브라우저 구성요소](https://all-young.tistory.com/22)
    
    **User Interface**
    
    - 사용자가 접근할 수 있는 영역이다.
    - 예를 들어, 검색창, 뒤로가기/앞으로가기 버튼, 새로 고침 버튼 등 브라우저 프로그램 자체의 GUI를 구성하는 부분이다.
    
    **Browser Engine**
    
    - User Interface와 Rendering Engine 사이의 동작을 제어해주는 엔진이다.
    - 브라우저라는 프로그램의 비즈니스 로직, 핵심 중추 부분이다.
    - Data Storage를 참조하며 로컬에 데이터를 쓰고 읽으면서 다양한 작업을 한다.
    
    **Rendering Engine**
    
    - **요청한 콘텐츠를 화면에 출력하는 역할이다.**
    - **HTML, CSS 등을 파싱하여 최종적으로 화면에 그린다.**
    
    **Networking**
    
    - http 요청을 할 수 있으며 네트워크를 호출할 수 있다.
    
    **JS Engine**
    
    - JavaScript 코드를 해석하고 실행한다.
    
    **UI Backend**
    
    - 기본적인 위젯을 그리는 인터페이스이다.
    
    **Data Storage**
    
    - Local Storage, Indexed DB, 쿠키 등 브라우저 메모리를 활용하여 저장하는 영역이다.

이런 내부 엔진들이 리소스를 받아와 어떻게 사용자 인터페이스로 보여주게 되는 걸까요?

## Critical Render Path

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%205.png)

브라우저는 ‘페이지에 변경사항이 생길 때마다’

- HTML, CSS, JS 리소스를 응답받아
- → 순차적으로 파싱하여 DOM + CSSOM을 생성하고
- → 그 둘을 렌더 트리로 합쳐 각 객체마다 위치와 크기를 부여하고
- → 브라우저 화면에 픽셀을 렌더링(페인팅)

하는 과정을 반복합니다. 이 과정을 Critical Render Path라고 부릅니다.

## MPA vs. SPA

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%206.png)

10여년 전까지만 하더라도 웹개발의 정석적인 방법론은 MPA(Multi-Page-Application)으로 여러 개의 HTML 파일을 렌더링이 필요할 때마다 통째로 로드해오는 방식이었습니다. 위 렌더링 과정을 반복할 때 생길 수 있는 문제점은 뭘까요? 

바로 리렌더링이 필요하지 않는 부분을 불필요하게 다시 렌더링하게 된다는 단점이 있습니다. 이는 페이지 전체를 새로고침할 수밖에 없게 만들었고 우리가 어렸을 때 웹서핑을 하다보면 페이지가 자주 깜빡거렸던 기억을 떠올릴 수 있을거에요.

단순히 정적인 페이지를 디스플레이하는 목적에는 그럭저럭이었지만, 웹 기술의 발전으로 동적이며 사용자들과 인터렉션 요소들이 웹페이지에 추가되면서 더이상 MPA 방식으로는 고차원의 웹페이지를 만들 수 없었습니다.

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%207.png)

그래서, 페이지 여러 개를 운용하는 방식이 아니라 한 페이지 안에서 바뀌는 부분들만 부분적으로 최신화하는 SPA(Single-Page-Application) 방법론이 대두되게 됩니다. 

이 방법론은 딱 한 번만 리소스(HTML, CSS, JavaScript)를 로딩합니다. 그 후에는 데이터를 받아올 때만 서버와 통신하죠. 즉, 첫 요청 시 딱 한 페이지만 불러오고 페이지 이동 시 기존 페이지의 내부를 수정해서 보여주는 방식입니다.

이를 클라이언트 관점에서 말하자면 최초 페이지를 로딩한 시점부터는 페이지 리로딩 없이 필요한 부분만 서버로 부터 받아서 화면을 갱신하는 것입니다. 필요한 부분만 갱신하기 때문에 네이티브 앱에 가까운 자연스러운 페이지 이동과 사용자 경험(UX)을 제공할 수 있다는 장점이 있죠.

## SPA의 절대 강자 React

![Untitled](Week%204-1%20%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%B5%E1%86%BC%20e5368b6a7ccb48e4a04df7fee72d5142/Untitled%208.png)

이후 저희가 배우게 될 React 라이브러리는 대표적인 SPA 프레임워크이며, 특히 갈수록 반응형 요소들이 많아지고 사용자들과 상호작용하는 기능들이 많아지는 웹에서 불필요한 리렌더링을 줄이기 위한 패러다임인 SPA(Single-Page-Application)가 거의 정석이라고 생각하시면 좋습니다.

웹페이지를 구성하는 방법론인 MPA/SPA 이외에도 웹페이지를 렌더링하는 방법론을 CSR(Client-Side Rendering)과 SSR(Server-Side Rendering)으로 나눌 수 있는데, 이 점은 지금보다 프로젝트 경험을 더 쌓은 뒤에 접하는 것이 이해가 쉽기 때문에 지금은 넘어가도록 하겠습니다 ㅎㅎ

브라우저의 내부 구조는 여기까지 알아보도록 하고 다음 페이지에서 DOM에 대해 더 자세하게 알아보겠습니다.