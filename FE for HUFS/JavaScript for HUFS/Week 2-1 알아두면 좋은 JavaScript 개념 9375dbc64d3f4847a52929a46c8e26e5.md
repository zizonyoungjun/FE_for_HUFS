# Week 2-1. 알아두면 좋은 JavaScript 개념

생성일: June 9, 2024 2:46 AM

지난 챕터에서는 우리가 앞으로 프론트엔드 개발을 하기 위해 꼭꼭 알아야 하는 JavaScript의 개념과 기초적인 문법들을 배워보았는데요, 이번 챕터에서는 JavaScript의 심화 개념에 대해 더 자세히 톺아보도록 하겠습니다!

---

## 1. 값에 의한 전달과 참조에 의한 전달

지난 챕터에서 배웠듯이 변수는 **바뀔 수 있는 값** 입니다! 여기서 변수의 값을 바꿔주는 것을 **할당**이라고 하는데요, 쉽게 생각해서 변수에 `=` 연산자를 사용한다면 변수 할당이 이루어지는 과정이라고 볼 수 있습니다. 

변수에는 여러가지 데이터 타입의 값을 할당할 수도 있지만, 다른 변수도 할당이 가능합니다. 이 때, 데이터 타입에 따라서 **값에 의한 전달**과 **참조에 의한 전달**로 구분이 되는데요, 자세히 어떻게 나눠지는지 알아봅시다! 

### **값에 의한 전달(Pass by Value)**

값에 의한 전달은 **`Boolean`, `Null`, `Undefined`, `String`, `Number` , 즉 원시 타입의 값**을 할당할 때 이루어집니다.

이를 이해하기 위해선, 변수 할당이 이루어지는 과정을 먼저 이해해야 하는데요! 
우리가 `let a = 100;` 이라는 코드를 입력하면 a라는 변수에 100이라는 정수 타입의 값이 바로 할당이 되는 것처럼 보이지만 사실 100이라는 정수가 저장되어있는 메모리 공간의 주소값이 a 변수에 할당이 된 것입니다! 

이해하셨나요?? a 변수는 사실 메모리의 주소값을 담고 있는거죠 ❕

---

다시 값에 의한 전달로 돌아와서…

원시 타입의 값이 할당되어 있는 변수를 다른 변수에 할당한다면 전달받는 변수는 기존 변수에 저장되어 있는 값을 다른 메모리 공간에 복사하여 그 주소값을 전달받게 됩니다! 둘은 완전 별개의 값이 되는거죠🧐

![값에 의한 전달.png](Week%202-1%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20JavaScript%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%209375dbc64d3f4847a52929a46c8e26e5/%25E1%2584%2580%25E1%2585%25A1%25E1%2586%25B9%25E1%2584%258B%25E1%2585%25A6_%25E1%2584%258B%25E1%2585%25B4%25E1%2584%2592%25E1%2585%25A1%25E1%2586%25AB_%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB%25E1%2584%2583%25E1%2585%25A1%25E1%2586%25AF.png)

```jsx
let score = 80; // 80이 저장되어 있는 메모리 공간의 주소값 X
let copy = score; // 80을 다른 메모리 공간 Y에 저장하여 전달받음!

score = 500 // 500을 저장한 새로운 메모리 공간 Z로 주소값 변경

console.log(copy);  // 80
```

위의 코드에서 변수 score과 copy는 전혀 다른 별개의 주소값을 참조하고 있기 때문에 score의 값이 변경되어도 copy의 값은 80으로 유지가 되는 것입니다!

### **참조에 의한 전달(Pass by Reference)**

참조에 의한 전달은 **`Array`, `Function`, `Object` , 즉 객체 타입의 값**을 할당할 때 이루어집니다.

값에 의한 전달과 달리 객체의 메모리 주소값(참조값)을 전달하는 방식으로 두 변수는 메모리 주소를 통해 결국 같은 객체를 가리키게 됩니다!

즉, 두 개의 변수가 하나의 객체를 공유하며 서로 영향을 주게 됩니다.

![참조에 의한 전달.png](Week%202-1%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20JavaScript%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%209375dbc64d3f4847a52929a46c8e26e5/%25E1%2584%258E%25E1%2585%25A1%25E1%2586%25B7%25E1%2584%258C%25E1%2585%25A9%25E1%2584%258B%25E1%2585%25A6_%25E1%2584%258B%25E1%2585%25B4%25E1%2584%2592%25E1%2585%25A1%25E1%2586%25AB_%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB%25E1%2584%2583%25E1%2585%25A1%25E1%2586%25AF.png)

```jsx
let person = {
  name : 'Lee'
} // 객체의 주소 X가 담겨있는 메모리 주소 Y

let copy = person; // 객체의 주소 X가 담겨있는 메모리 주소 Z
// 결국 두 변수는 같은 객체를 가리키게 됨!

console.log(person.name, copy.name); // Lee Lee

copy.name = 'Kim';

console.log(person.name, copy.name); // Kim Kim
```

위의 코드에서 변수 person과 copy는 하나의 객체를 공유하며 영향을 주고 있기 때문에 변수 copy의 name값만 변경해도 변수 person까지 영향을 미치게 됩니다!

---

## 2. 암묵적 타입 변환

**타입 변환**이란 특정 데이터 타입을 다른 타입으로 바꾸는 것을 말합니다! 개발자가 의도적으로 타입을 변환하는 것은 **명시적 타입 변환**, JavaScript 엔진에 의해 암묵적으로 자동으로 타입이 변환되는 것을 **암묵적 타입 변환**이라고 합니다. 따로 처리해주지 않아도 자동으로 타입 변환이 되기 때문에 편하면서도 조심해야 하는 기능입니다! 그렇기 때문에 잘 이해하고 코드를 작성하는 것이 중요하겠죠❓🙃

### **1) 문자열 타입으로 변환**

`+` 연산자를 사용할 때 피연산자 중 하나 이상의 문자가 포함되면 문자열로 타입을 변환합니다.

```jsx
1 + '2' // '12'
1 + 'ab' // '1ab'
10 + ' ' // '10'
true + ' ' // 'true'
```

### **2) 숫자 타입으로 변환**

`+` 가 아닌 산술 연산자의 경우 숫자타입이 아닌 피연산자를 숫자로 변환합니다.

```jsx
1 - '2' // -1
9 - '3' // 6
9 * '3' // 27
9 / '3' // 3
```

`<`, `>` 연산자는 숫자타입이 아닌 피연산자를 숫자로 변환합니다.

```jsx
9 > '3' // true
'9' < '3' // false
```

`+` 단항 연산자는 숫자타입이 아닌 피연산자를 숫자로 변환합니다. 

```jsx
+'5' // 5
+' ' // 0
+true // 1
+false // 0
+null // 0
```

### **3) Boolean 타입으로 변환**

지난 챕터에서 배웠던 **Truthy**와 **Falsy**가 바로 암묵적 타입 변환 중 하나입니다!!

true로 형변환을 강제하는 것을 Truthy라고 하고, false로 형변환을 강제하는 것을 Falsy 라고 합니다. 

자바스크립트에서 Falsy로 취급되는 값은 `false`, `0`, `null`, `undefined`, `''`, `NaN`, `-0`

이렇게 총 7가지인데요, 이 외에는 전부 Truthy로 취급합니다.

```jsx
if(-1) // truthy
if('0') // truthy
if(0) // falsy
```

위의 코드처럼 Truthy를 사용해도 코드 상에는 전혀 문제가 없지만 **참인 값을 명시적으로 표현해주는 것**이 더 좋은 방법입니다.

```jsx
let a = 2;
if (a === 2) // true
```

이렇게 말이죠.

자바스크립트의 암묵적 타입 변환을 완벽히 이해하더라도, 이에 의존하지 않고 명시적으로 **이해하기 쉽게 코드를 작성해주면 좋을 것 같습니다!!**

---

## 3. this 바인딩

지난 챕터에서 객체에 대해 배우면서 **`this`** 라는 단어를 마주쳤을텐데요, 
일반적인 프로그래밍 언어에서의 this는 보통 자기자신을 가리키는 참조변수입니다!
하지만 JavaScript에서는 다른 객체지향 언어와 다르게 this 바인딩이 동적으로 결정됩니다.

즉, **어떤 객체가 호출하냐(함수 호출 방식)에 따라서 this가 참조하는 객체가 달라집니다**. 

JavaScript에서는 this를 어떻게 사용할 수 있는지 알아봅시다👊
(저희는 웹 프론트엔드를 개발할 예정이기 때문에 브라우저를 기준으로 작성하였습니다)

### **1) 기본 바인딩 (일반 함수 호출 시)**

먼저 개발자 도구를 열어서 콘솔에 **`console.log(this)`** 를 입력해보세요!

![Untitled](Week%202-1%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%83%E1%85%AE%E1%84%86%E1%85%A7%E1%86%AB%20%E1%84%8C%E1%85%A9%E1%87%82%E1%84%8B%E1%85%B3%E1%86%AB%20JavaScript%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%209375dbc64d3f4847a52929a46c8e26e5/Untitled.png)

← Window가 반환되는 것을 보실 수 있죠

이처럼 기본 바인딩이 적용될 경우 **this는 전역 객체(브라우저 환경 = Window)에 바인딩**됩니다. 

```jsx
function printName() {
  const name = '김멋사';
  console.log(this.name); // this는 전역 객체 window
}

printName(); // undefined
```

위의 코드에서 undefined가 출력되는 이유는 this가 전역객체에 바인딩되었는데 전역객체인 window에는 name이라는 프로퍼티가 없기 때문입니다. 

```jsx
window.name = '김멋사';

function printName() {
  console.log(this.name);
}

printName(); // 김멋사
```

이처럼 전역객체 window에 name 프로퍼티를 추가한 후 this를 이용해서 출력해주면 name이 그대로 출력되는 것을 볼 수 있습니다!

### **2) 암시적 바인딩 (메소드 호출 시)**

❗️JavaScript에서 메소드(method)란? 
→ 객체 안에 프로퍼티로 정의된 함수를 말함.

함수가 객체의 메소드로서 호출되는 상황에서 **this는 암시적 바인딩**됩니다.
이때 this는 **해당 함수를 호출한 객체**에 바인딩됩니다. 

```jsx
const student = {
  name: '김멋사',
  func: function printName() {
    console.log(this.name); // this는 호출한 객체 student
	}
}

student.func(); // 김멋사
```

### 3**) new 바인딩 (생성자 함수 호출 시)**

new 키워드 사용 시 **새로 생성된 객체**로 this가 바인딩됩니다. 

```jsx
function Student(name) {
  this.name = name;
}

const kim = new Student('김멋사'); // this는 새로운 객체 kim

console.log(kim.name); // 김멋사
```

### 4**) 명시적 바인딩 (call/apply/bind 호출 시)**

자바스크립트의 모든 function은 `call()`, `apply()`, `bind()` 라는 프로토타입 메서드를 가지고 있습니다. 이 3가지 메서드를 사용해서 바인딩할 객체를 명시해주는 것을 명시적 바인딩이라고 합니다. 이때 this는 call, apply, bind 의 **파라미터로 넘어온 객체**를 가리킵니다. 

**call(), apply()**

```jsx
const kim = {
  name: '김멋사',
}

const lee = {
  name: '이멋사',
}

function printName() {
  console.log(this.name);
}

printName.call(kim); // 김멋사
printName.apply(lee); // 이멋사
```

위의 코드처럼 call과 apply는 똑같이 인자로 들어온 객체를 this에 바인딩해주고 함수를 실행하는데 둘의 차이점은 무엇일까요?

```jsx
function printInfo(city, side) {
	console.log(`${this.name}는 ${city}에 사는 ${side} 개발자입니다.`);
}

printInfo.call(kim, '이문동', '프론트엔드'); 
// 김멋사는 이문동에 사는 프론트엔드 개발자입니다.
printInfo.apply(lee, ['공릉동', '백엔드']); 
// 이멋사는 공릉동에 사는 백엔드 개발자입니다.
```

위의 코드처럼 call과 apply의 동작은 같지만 두번째 매개변수로 객체의 인자를 전달해줄 때 call은 매개변수의 **목록**, apply는 **배열**을 받는다는 차이점이 있습니다.

**bind()**

bind는 위에서 본 call/apply와 달리 함수를 실행하진 않지만 this가 객체를 영구적으로 가리키도록 할 수 있습니다!

```jsx
const kim = {
  name: '김멋사'
}

function printKim() {
  console.log(this.name);
}

const bind = printKim.bind(kim) // kim으로 바인딩된 printKim함수 반환

// function printKim() {
// 	console.log(kim.name);
// } 
// 와 같음

bind(); // 김멋사
```

bind 메서드는 **매개변수로 전달받은 객체로 this가 바인딩된 함수를 반환**합니다. 이것을 **하드 바인딩**이라고 하는데 하드 바인딩된 함수는 이후 호출될 때마다 처음 정해진 this 바인딩을 가지고 호출됩니다. 
위의 코드에서 printKim 함수의 this는 kim 객체로 하드바인딩 되었기 때문에 호출할 때마다 this가 가리키는 kim 객체의 name이 출력되는 것을 볼 수 있습니다 :)

### **+) 화살표 함수**

지난 챕터에서 배운 화살표 함수를 기억하실 텐데요, 이 화살표 함수에서는 this를 바인딩할 때 앞의 4가지 규칙이 적용되지 않습니다. 

앞서 말한 것과 달리 **화살표 함수는 this가 정적으로 결정**되고, 화살표 함수를 **정의하는 시점**의 컨텍스트 객체가 this에 바인딩됩니다. (위의 4가지 규칙은 **호출 시점**에 this가 바인딩됨)
쉽게 말해서 **화살표 함수 밖에서 제일 근접한 스코프의 this**를 가리키게 됩니다. 

```jsx
const student = {
	name: '김멋사',
	say: function () {
		introduction = () => `저는 ${this.name}입니다.`;
		// 가장 근접한 상위 스코프인 student 객체에 바인딩!
		console.log(introduction());
	}
}

student.say(); // 저는 김멋사입니다.
```

---

모두 잘 따라오고 계신가요!  다음 챕터에 이어집니다..🤓